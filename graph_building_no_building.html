<html>
  <head>
    <title>Graph City Building</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- <link type="text/css" rel="stylesheet" href="./three.js/editor/css/main.css"> -->
    <script src="lib/jquery-3.5.1.min.js"> </script>
    <style>
      body { margin: 0; }
      canvas { display: block; }
    </style>
    <script> 
        function locationreload() { 
            location.reload(); 
        } 
    </script> 
  </head>
  <body>
    <script type="module">
      import * as THREE from './node_modules/three/build/three.module.js';
      import { TrackballControls } from './node_modules/three/examples/jsm/controls/TrackballControls.js';
      import { GUI } from './node_modules/three/examples/jsm/libs/dat.gui.module.js';
      import { BufferGeometryUtils } from './three.js/examples/jsm/utils/BufferGeometryUtils.js';
      import { OBJLoader } from './three.js/examples/jsm/loaders/OBJLoader.js';
      import { Water } from './three.js/examples/jsm/objects/Water.js';
      import { Sky } from './three.js/examples/jsm/objects/Sky.js';
      // THREE.Cache.enabled = true;

      let perspectiveCamera, orthographicCamera, controls, scene, renderer;

      let spiral = [];
      let frustumSize = 400;
      let aspect = window.innerWidth/window.innerHeight;
      scene = new THREE.Scene();
      scene.background = new THREE.Color('skyblue');
      // let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();
      let objects = [];
      let INTERSECTED;
      let city_tracking = {};
      let city_all = {};
      let city_mesh = [];
      let city_to_load = 0;
      let groundMesh;
      let source_dir = "data/";
      let land_obj = "models/island.obj";
      // let source_dir;
      // let y_scale = 50; // scale up the height of building
      let last = [-187.86920742571192,-69.84011743155536]
      let y_scale = Math.sqrt(last[0] ** 2 + last[1] ** 2) / 4.565727849181679;
      // let x_scale = 800000.0; // scale down the coordinates span
      let x_scale = 1;
      let default_persp = [0,200,400]
        // GUI parameters
        let params = {
            orthographicCamera: false,
            resetCamera: function() {
                // TrackballControls.reset();
            },
            ground: "#CCA262",
            colorMap: "jet",
            hideBuilding: false
        };
        let building_params = {
            floor: '',
            layer: ''
        };
      let water;
      init();
      animate();

      function init() {
        perspectiveCamera = new THREE.PerspectiveCamera( 60, aspect, 1, 2000 );
        perspectiveCamera.position.z = 800;
        perspectiveCamera.position.y = 500;
        // perspectiveCamera.position.z = 5;
        // perspectiveCamera.position.y = 7;

        orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );
        orthographicCamera.position.z = 20;

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        
        let manager = new THREE.LoadingManager();
        manager.onStart = function(url,itemsLoaded,itemsTotal) {
          console.log('Started loading file: '+url+'.\nLoaded '+itemsLoaded+' of '+itemsTotal+' files.');
        };

        // GUI folders
        let gui = new GUI();
        let f1 = gui.addFolder('Building Info');
        f1.add(building_params, 'floor').name('floor number').listen();
        f1.add(building_params, 'layer').name('layer info').listen();
        f1.add(params, 'colorMap', ['jet','others']).name('color map').onChange(function () {
            // updateColorMap();
            render();
        });
        f1.open();
        let f2 = gui.addFolder('Camera Control');
        f2.add(params, 'resetCamera').name('reset camera');
        f2.add(params, 'orthographicCamera').name('use orthographic').onChange(
            function( value ) {
                // controls.dispose();
            createControls( value ? orthographicCamera : perspectiveCamera );
        });
        f2.open();
        let f3 = gui.addFolder('Environment Control');
        f3.addColor(params, 'ground').name('ground color').onChange( function( colorValue ) {
            colorValue = parseInt(colorValue.replace('#','0x'), 16);
            let colorObject = new THREE.Color( colorValue );
            groundMesh.material.color = colorObject;
            animate();
        });
        f3.open();

        // ground
        // let groundGeo = new THREE.BoxBufferGeometry(800,0.1,800);
        let groundMat = new THREE.MeshBasicMaterial( {color:params.ground} );
        groundMat.side = THREE.DoubleSide;
        // groundMesh = new THREE.Mesh( groundGeo, groundMat );
        // groundMesh.translateY(-0.5);
        // scene.add( groundMesh );

        let groundUrl = "models/island.obj";
        let groundMesh = objLoader(groundUrl, groundMat);

        document.body.appendChild( renderer.domElement );
        document.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'resize', onWindowResize, false );
        // window.addEventListener( 'reset_camera', onResetCamera, false);
        createControls( perspectiveCamera );

        //grid helper
        // let size = 800;
        // let divisions = 32;
        // let gridHelper = new THREE.GridHelper( size, divisions );
        // scene.add( gridHelper );

        let sun = new THREE.Vector3();
        //water
        let waterGeo = new THREE.PlaneBufferGeometry(10000,10000);
        water = new Water( waterGeo, {
            textureWidth: 512, 
            textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load( 'textures/waternormals.jpg', function ( texture ) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            } ),
            alpha:  1.0,
            sunDirection: new THREE.Vector3(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 4,
        } );
        water.rotation.x = - Math.PI/2;
        scene.add(water);

        //skybox
        var sky = new Sky();
        sky.scale.setScalar(10000);
        scene.add(sky);
        var uniforms = sky.material.uniforms;
        uniforms[ 'turbidity' ].value = 10;
        uniforms[ 'rayleigh' ].value = 2;
        uniforms[ 'mieCoefficient' ].value = 0.005;
        uniforms[ 'mieDirectionalG' ].value = 0.8;
        var parameters = {
            inclination: 0.35,
            azimuth: 0.205
        };
        var pmremGenerator = new THREE.PMREMGenerator( renderer );
        function updateSun() {
            var theta = Math.PI * ( parameters.inclination - 0.5 );
            var phi = 2 * Math.PI * ( parameters.azimuth - 0.5 );
            sun.x = Math.cos( phi );
            sun.y = Math.sin( phi ) * Math.sin( theta );
            sun.z = Math.sin( phi ) * Math.cos( theta );
            sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
            water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();
            scene.environment = pmremGenerator.fromScene( sky ).texture;
        }
        updateSun();
      }

      function objLoader(obj_url,obj_material) {
        var loader = new OBJLoader();
        loader.load(
            obj_url,
            function ( object ) {
                object.traverse(function(child){
                    console.log("child type: "+child.type);
                    if(child.type == "Mesh") {
                        child.material = obj_material;
                    }
                });
                object.position.x=-100;
                object.scale.set(20,1,20);
                
                scene.add( object );
            },
            function ( xhr ) {
                console.log( obj_url + ' ' + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            function ( error ) {
                console.log( 'An error happened when loading ' + obj_url );
            }
        );
      }

      function createControls( camera ) {
        controls = new TrackballControls( camera, renderer.domElement );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.keys = [ 65, 83, 68 ];
      }

      function onWindowResize() {

        let aspect = window.innerWidth / window.innerHeight;

        perspectiveCamera.aspect = aspect;
        perspectiveCamera.updateProjectionMatrix();

        orthographicCamera.left = - frustumSize * aspect / 2;
        orthographicCamera.right = frustumSize * aspect / 2;
        orthographicCamera.top = frustumSize / 2;
        orthographicCamera.bottom = - frustumSize / 2;
        orthographicCamera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

      }
      
      function animate() {
        requestAnimationFrame( animate );
        controls.update();
        // stats.update();
        if(city_to_load>0) {
          console.log("animate: run createCityMeshes()");
          createCityMeshes();

        }
        render();
      }

      function render() {
        let camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
        renderer.render(scene, camera);
        // let time = performance.now() * 0.001;
        // water.material.uniforms[ 'time' ].value += 1.0 / 60.0;
      }

      function onMouseMove( event ) {
        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
        let camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
        raycaster.setFromCamera( mouse, camera );

        let intersects = raycaster.intersectObjects( objects );
        // Toggle rotation bool for meshes that we clicked
        if (intersects.length > 0) {
          // if the closest object intersected is not the currently stored intersection object
          if (intersects[0].object != INTERSECTED ) {
            INTERSECTED = intersects[0].object;
            if(intersects[0].object.floor_name) {
              building_params.floor = intersects[0].object.floor_name;
            } else {
              building_params.floor = '';
            }
            if(intersects[0].object.layer_name) {
              building_params.layer = intersects[0].object.layer_name;
            } else {
              building_params.layer = '';
            }
          }
        } else // there are no intersections
        {
          INTERSECTED = null;
          building_params.floor='';
          building_params.layer='';
        }
      }
    </script>
  </body>
</html>