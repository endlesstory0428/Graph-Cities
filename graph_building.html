<html>
	<head>
		<title>Graph City Building</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!-- <link type="text/css" rel="stylesheet" href="./three.js/editor/css/main.css"> -->
		<script src="lib/jquery-3.5.1.min.js"> </script>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script type="module">
			import * as THREE from './node_modules/three/build/three.module.js';
			import { TrackballControls } from './node_modules/three/examples/jsm/controls/TrackballControls.js';
			import { GUI } from './node_modules/three/examples/jsm/libs/dat.gui.module.js';
			THREE.Cache.enabled = true;

			var perspectiveCamera, orthographicCamera, controls, scene, renderer;

			var params = {
				orthographicCamera: false
			};
			var building = {
			    floor: ''
			};
			var spiral = [];
			var frustumSize = 400;
			var aspect = window.innerWidth/window.innerHeight;
			var scene = new THREE.Scene();
			scene.background = new THREE.Color('skyblue');
			// var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();
			var gui = new GUI();
			var objects = [];
			var INTERSECTED;
			var city_tracking = {};
			var city_all = {};
			
			init();
			animate();

			function init() {
				perspectiveCamera = new THREE.PerspectiveCamera( 60, aspect, 1, 1000 );
				perspectiveCamera.position.z = 20;

				orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );
				orthographicCamera.position.z = 20;

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				
				var manager = new THREE.LoadingManager();
				manager.onStart = function(url,itemsLoaded,itemsTotal) {
					console.log('Started loading file: '+url+'.\nLoaded '+itemsLoaded+' of '+itemsTotal+' files.');
				};
				// manager.onLoad = function() {
				// 	console.log('Loading complete!');
				// }
				// manager.onProgress = function(url,itemsLoaded,itemsTotal) {
				// 	console.log('Started loading file: '+url+'.\nLoaded '+itemsLoaded+' of '+itemsTotal+' files.');
				// };
				// manager.onError = function(url) {
				// 	console.log('There was an error loading '+url);
				// }


				loadFile('data/',manager);

				var heights = [0,0.0877794886782907,0.13128609409319691,0.1747926995081031,0.22819410025109796,0.2815955009940928,0.35019479832400946,0.4187940956539261,0.6061428892410488];
				for(var i=0;i<heights.length;i++) {
					heights[i]*=10;
				}
				var radius = [6.066089190457772,3.0,3.4594316186372973,2.321928094887362,2.584962500721156,0.98,2.0,1.0,1.584962500721156];
				var floor1 = new THREE.CylinderBufferGeometry(radius[1], radius[0], heights[1]-heights[0], 16, 16);
				floor1.translate(0,heights[1]/2,0);
				var floor2 = new THREE.CylinderBufferGeometry(radius[2], radius[1], heights[2]-heights[1], 16, 16);
				floor2.translate(0,heights[1]+(heights[2]-heights[1])/2,0);
				var floor3 = new THREE.CylinderBufferGeometry(radius[3], radius[2], heights[3]-heights[2], 16, 16);
				floor3.translate(0,heights[2]+(heights[3]-heights[2])/2,0);
				var floor4 = new THREE.CylinderBufferGeometry(radius[4], radius[3], heights[4]-heights[3], 16, 16);
				floor4.translate(0,heights[3]+(heights[4]-heights[3])/2,0);
				var floor5 = new THREE.CylinderBufferGeometry(radius[5], radius[4], heights[5]-heights[4], 16, 16);
				floor5.translate(0,heights[4]+(heights[5]-heights[4])/2,0);
				var floor6 = new THREE.CylinderBufferGeometry(radius[6], radius[5], heights[6]-heights[5], 16, 16);
				floor6.translate(0,heights[5]+(heights[6]-heights[5])/2,0);
				var floor7 = new THREE.CylinderBufferGeometry(radius[7], radius[6], heights[7]-heights[6], 16, 16);
				floor7.translate(0,heights[6]+(heights[7]-heights[6])/2,0);
				// Colors
				var material1 = new THREE.MeshBasicMaterial({color:0xEC3613});
				var material2 = new THREE.MeshBasicMaterial({color:0xECA113});
				var material3 = new THREE.MeshBasicMaterial({color:0xC1EC13});
				var material4 = new THREE.MeshBasicMaterial({color:0x13EC13});
				var material5 = new THREE.MeshBasicMaterial({color:0x1313EC});

				// Mesh
				var frustum_mesh_1 = new THREE.Mesh(floor1, material1);
				frustum_mesh_1.name="floor 1"
				var frustum_mesh_2 = new THREE.Mesh(floor2, material2);
				frustum_mesh_2.name="floor 2"
				var frustum_mesh_3 = new THREE.Mesh(floor3, material2);
				frustum_mesh_3.name="floor 3"
				var frustum_mesh_4 = new THREE.Mesh(floor4, material3);
				frustum_mesh_4.name="floor 4"
				var frustum_mesh_5 = new THREE.Mesh(floor5, material3);
				frustum_mesh_5.name="floor 5"
				var frustum_mesh_6 = new THREE.Mesh(floor6, material4);
				frustum_mesh_6.name="floor 6"
				var frustum_mesh_7 = new THREE.Mesh(floor7, material5);
				frustum_mesh_7.name="floor 7"
				// var frustum_mesh_3 = new THREE.Mesh(floor2, material2);
				// var building_mesh_1 = new THREE.Mesh(THREE.Geometry());
				// building_mesh_1.merge(floor1);
				// building_mesh_1.merge(floor2);
				// var building_mesh_1 = new THREE.Mesh(building1,material1);
				// scene.add(building_mesh_1);
				scene.add(frustum_mesh_1);
				scene.add(frustum_mesh_2);
				scene.add(frustum_mesh_3);
				scene.add(frustum_mesh_4);
				scene.add(frustum_mesh_5);
				scene.add(frustum_mesh_6);
				scene.add(frustum_mesh_7);
				objects.push(frustum_mesh_1);
				objects.push(frustum_mesh_2);
				objects.push(frustum_mesh_3);
				objects.push(frustum_mesh_4);
				objects.push(frustum_mesh_5);
				objects.push(frustum_mesh_6);
				objects.push(frustum_mesh_7);

				// camera.position.z = 15;
				// camera.position.y = 2;

				
				gui.add( params, 'orthographicCamera' ).name( 'use orthographic' ).onChange( function ( value ) {

					controls.dispose();

					createControls( value ? orthographicCamera : perspectiveCamera );

				} );

				gui.add(building, 'floor').name('floor number').listen();

				document.body.appendChild( renderer.domElement );
				document.addEventListener( 'mousemove', onMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );
				createControls( perspectiveCamera );	
			}

			function loadFile(file,manager) {
				var loader = new THREE.FileLoader(manager);
				var blob = null;
				loader.responseType = "blob";
				loader.load(file,
					function(data) {
						getAsText(data,file);
					},
					function(xhr) {
						console.log((file+' '+xhr.loaded/xhr.total*100)+'% loaded');
					},
					function(err) {
						console.error('An error happened when loading '+file);
					}
				);
			}

			function getAsText(file,url) {
				var reader = new FileReader();
				reader.readAsText(file);
				reader.onProgress = updateProgress;
				reader.onload = loaded;
				reader.onerror = errorHandler;
				reader.url = url;
				var text = reader.result;
			}

			function updateProgress(evt) {
				if(evt.lengthComputable) {
					var loaded = (evt.loaded/evt.total);
				}
			}

			function loaded(evt) {
				var fileString = evt.target.result;
				var isFolder = fileString.startsWith("<!DOCTYPE HTML PUBLIC");
				var lines = null;
				if(isFolder) {
					lines = fileString.split('\n');
					var doc = new DOMParser().parseFromString(fileString, "text/html");
					var files = doc.getElementsByTagName("LI");
					for(var i=0;i<files.length;i++){
						loadFile("data/"+files[i].firstChild.innerHTML);
					}
				} else {
					var filename = evt.target.url;
					var layer_name;
					lines = fileString.split('\n');
					var element_count = (lines[0].split(' ')).length;
					if(element_count == 4) {
						loadSpiral(lines,filename);
					} else if(element_count == 6) {
						console.log("color file");
						layer_name = fileToLayer(filename);
						loadColor(lines,layer_name);
					} else if(element_count == 3) {
						console.log("floor file");
						layer_name = fileToLayer(filename);
						loadFloor(lines,layer_name);
					}
				}
			}

			function fileToLayer(filename) {
				var start = filename.lastIndexOf('/');
				var end = filename.lastIndexOf('_');
				return filename.substring(start+1,end);
			}

			function getLayerAllObj(layer_name) {
				var layer_all = {
					coords:[],
					colors:{},
					shapes:[]
				};
				return layer_all;
			}

			function getLayerTrackingObj(layer_name) {
				var layer_tracking = {
					ready_to_move: false,
					ready_to_color: false
				};
				return layer_tracking;
			}

			function printGlobalDict(func) {
				console.log(func + ": city_all");
				console.log(city_all);
				console.log(func + ": city_tracking");
				console.log(city_tracking);
			}

			// add a new floor shape to a given building
			function addNewFloor(layer_name, h, inner_r, outer_r) {
				var floor = {
					height: h,
					inner_radius: inner_r,
					outer_radius: outer_r
				}
				city_all[layer_name].shapes.push(floor);
			}

			// take layer name and lines from floor file, update the shape of building
			function loadFloor(lines,layer_name) {
				console.log("loadFloor: "+layer_name);
				if (!(layer_name) in city_all) {
					city_all[layer_name] = getLayerAllObj(layer_name);
				} else if (!(layer_name) in city_all) {
					city_all[layer_name] = getLayerTrackingObj(layer_name);
				}
				var i;
				var tmp_outer_radius = 0;
				for(i=0; i<lines.length-1; i++) {
					var elements = lines[i].split(' ');
					console.log("loadFloor: floor "+i);
					console.log(elements);
					if (elements[1] == 0) {
						console.log("loadFloor: add new floor "+city_all[layer_name].shapes.length);
						addNewFloor(layer_name,0.0,parseFloat(elements[2]),0.0);
					} else if (i%2 == 1 && i < lines.length-2) {
						tmp_outer_radius = elements[2];
					} else {
						console.log("loadFloor: add new floor "+city_all[layer_name].shapes.length);
						if(i == lines.length-2) {
							tmp_outer_radius = 0;
						}
						addNewFloor(layer_name,parseFloat(elements[1]),parseFloat(elements[2]),parseFloat(tmp_outer_radius));
					}
				}
				// shape of building is ready, check if coordinated is ready
				if(city_all[layer_name].coords.length > 0) {
					city_tracking[layer_name].ready_to_move = true;
				}
				printGlobalDict("loadFloor");
			}

			// take color file of a layer and save information to global dictionary
			function loadColor(color_list,layer_name) {
				// console.log("loadColor: " +layer_name);
				if (!(layer_name in city_all)) {
					city_all[layer_name] = getLayerAllObj(layer_name);
				}
				if (!(layer_name in city_tracking)) {
					city_tracking[layer_name] = getLayerTrackingObj(layer_name);
				}
				// inner structure of colors in layer_all dictionary
				var color_dict = {
					disc:[],
					inner:[],
					outer:[]
				};
				// read lines from a color file into "colors" dictionary
				var i;
				for(i=0; i<color_list.length; i++) {
					var elements = color_list[i].split(' ');
					var rgb = {
							r: elements[3],
							g: elements[4],
							b: elements[5]
					};
					if (color_list[i].search("disc")>0) {
						color_dict.disc.push(rgb);
					} else if (color_list[i].search("inner")>0) {
						color_dict.inner.push(rgb);
					} else if (color_list[i].search("outer")>0) {
						color_dict.outer.push(rgb);
					}
				}
				city_tracking[layer_name].ready_to_color = true;
				printGlobalDict("loadColor");
			}

			function loadSpiral(lines,filename) {
				console.log("loading spiral");
				console.log(filename);
				var scale = 80000.0; // scale down the coordinates span
				for(var i=0; i<lines.length-1; i++) {
					var elements = lines[i].split(' ');
					var layer_name = elements[0];
					//update global dictionaries if new layer appears
					if (!(layer_name in city_tracking)) {
						city_tracking[layer_name] = getLayerTrackingObj(layer_name);
					}
					if (!(layer_name in city_all)) {
						city_all[layer_name] = getLayerAllObj(layer_name);
					}
					city_all[layer_name].coords = [elements[1]/scale, elements[2]/scale];
					//coordinates is ready, check if shape of building is ready
					if(city_all[layer_name].shapes.length > 0) {
						city_tracking[layer_name].ready_to_move = true;
					}
				}
				printGlobalDict("loadSpiral");
			}

			function errorHandler(evt) {
				if(evt.target.error.name == "NotReadableError") {
					console.log("The file could not be read");
				}
			}

			function createControls( camera ) {
				controls = new TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.keys = [ 65, 83, 68 ];
			}

			function onWindowResize() {

				var aspect = window.innerWidth / window.innerHeight;

				perspectiveCamera.aspect = aspect;
				perspectiveCamera.updateProjectionMatrix();

				orthographicCamera.left = - frustumSize * aspect / 2;
				orthographicCamera.right = frustumSize * aspect / 2;
				orthographicCamera.top = frustumSize / 2;
				orthographicCamera.bottom = - frustumSize / 2;
				orthographicCamera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();

			}
			
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				// stats.update();
				render();
			}

			function render() {
				var camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
				renderer.render(scene, camera);
			}

			function onMouseMove( event ) {
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				var camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );
				// Toggle rotation bool for meshes that we clicked
				if ( intersects.length > 0 ) {
					// if the closest object intersected is not the currently stored intersection object
					if ( intersects[ 0 ].object != INTERSECTED ) 
					{
						INTERSECTED = intersects[ 0 ].object;
						if ( intersects[ 0 ].object.name )
						{
							building.floor=intersects[ 0 ].object.name;
						}
						else
						{
							building.floor='';
						}
					}
				} else // there are no intersections
				{
					INTERSECTED = null;
					building.floor='';
				}
			}
		</script>
	</body>
</html>