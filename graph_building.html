<html>
  <head>
    <title>Graph City Building</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- <link type="text/css" rel="stylesheet" href="./three.js/editor/css/main.css"> -->
    <script src="lib/jquery-3.5.1.min.js"> </script>
    <style>
      body { margin: 0; }
      canvas { display: block; }
    </style>
    <script> 
        function locationreload() { 
            location.reload(); 
        } 
    </script> 
  </head>
  <body>
    <script type="module">
      import * as THREE from './node_modules/three/build/three.module.js';
      import { TrackballControls } from './node_modules/three/examples/jsm/controls/TrackballControls.js';
      import { GUI } from './node_modules/three/examples/jsm/libs/dat.gui.module.js';
      import { BufferGeometryUtils } from './three.js/examples/jsm/utils/BufferGeometryUtils.js';
      import { OBJLoader } from './three.js/examples/jsm/loaders/OBJLoader.js';
      import { Water } from './three.js/examples/jsm/objects/Water.js';
      import { Sky } from './three.js/examples/jsm/objects/Sky.js';
      // THREE.Cache.enabled = true;

      let perspectiveCamera, orthographicCamera, controls, scene, renderer;

      let spiral = [];
      let frustumSize = 400;
      let aspect = window.innerWidth/window.innerHeight;
      scene = new THREE.Scene();
      scene.background = new THREE.Color('skyblue');
      // let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();
      let objects = [];
      let INTERSECTED;
      let city_tracking = {};
      let city_all = {};
      let city_mesh = [];
      let city_to_load = 0;
      let groundMesh;
      let source_dir = "data/";
      let land_obj = "models/island.obj";
      // let source_dir;
      // let y_scale = 50; // scale up the height of building
      let last = [-187.86920742571192,-69.84011743155536]
      let y_scale = Math.sqrt(last[0] ** 2 + last[1] ** 2) / 4.565727849181679;
      // let x_scale = 800000.0; // scale down the coordinates span
      let x_scale = 1;
      let default_persp = [0,200,400]
        // GUI parameters
        let params = {
            orthographicCamera: false,
            resetCamera: function() {
                // TrackballControls.reset();
            },
            ground: "#CCA262",
            colorMap: "jet",
            hideBuilding: false
        };
        let building_params = {
            floor: '',
            layer: ''
        };
      let water;
      init();
      animate();

      function init() {
        perspectiveCamera = new THREE.PerspectiveCamera( 60, aspect, 1, 2000 );
        perspectiveCamera.position.z = 900;
        perspectiveCamera.position.y = 400;
        perspectiveCamera.far = 5000;

        orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );
        orthographicCamera.position.z = 20;

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        
        let manager = new THREE.LoadingManager();
        manager.onStart = function(url,itemsLoaded,itemsTotal) {
          console.log('Started loading file: '+url+'.\nLoaded '+itemsLoaded+' of '+itemsTotal+' files.');
        };

        loadFile(source_dir,manager);

        // GUI folders
        let gui = new GUI();
        let f1 = gui.addFolder('Building Info');
        f1.add(building_params, 'floor').name('floor number').listen();
        f1.add(building_params, 'layer').name('layer info').listen();
        f1.add(params, 'colorMap', ['jet','others']).name('color map').onChange(function () {
            // updateColorMap();
            render();
        });
        f1.open();
        let f2 = gui.addFolder('Camera Control');
        f2.add(params, 'resetCamera').name('reset camera');
        f2.add(params, 'orthographicCamera').name('use orthographic').onChange(
            function( value ) {
                // controls.dispose();
            createControls( value ? orthographicCamera : perspectiveCamera );
        });
        f2.open();
        let f3 = gui.addFolder('Environment Control');
        f3.addColor(params, 'ground').name('ground color').onChange( function( colorValue ) {
            colorValue = parseInt(colorValue.replace('#','0x'), 16);
            let colorObject = new THREE.Color( colorValue );
            groundMesh.material.color = colorObject;
            animate();
        });
        f3.open();

        // ground
        // let groundGeo = new THREE.BoxBufferGeometry(800,0.1,800);
        let groundMat = new THREE.MeshBasicMaterial( {color:params.ground} );
        groundMat.side = THREE.DoubleSide;
        // groundMesh = new THREE.Mesh( groundGeo, groundMat );
        // groundMesh.translateY(-0.5);
        // scene.add( groundMesh );

        let groundUrl = "models/island.obj";
        let groundMesh = objLoader(groundUrl, groundMat);

        document.body.appendChild( renderer.domElement );
        document.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'resize', onWindowResize, false );
        // window.addEventListener( 'reset_camera', onResetCamera, false);
        createControls( perspectiveCamera );

        // let size = 1200;
        // let divisions = 24;
        // let gridHelper = new THREE.GridHelper( size, divisions );
        // scene.add( gridHelper );

        let sun = new THREE.Vector3();
        //water
        let waterGeo = new THREE.PlaneBufferGeometry(10000,10000);
        water = new Water( waterGeo, {
            textureWidth: 512, 
            textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load( 'textures/waternormals.jpg', function ( texture ) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            } ),
            alpha:  1.0,
            sunDirection: new THREE.Vector3(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 4,
        } );
        water.rotation.x = - Math.PI/2;
        scene.add(water);

        //skybox
        var sky = new Sky();
        sky.scale.setScalar(10000);
        scene.add(sky);
        var uniforms = sky.material.uniforms;
        uniforms[ 'turbidity' ].value = 10;
        uniforms[ 'rayleigh' ].value = 2;
        uniforms[ 'mieCoefficient' ].value = 0.005;
        uniforms[ 'mieDirectionalG' ].value = 0.8;
        var parameters = {
            inclination: 0.35,
            azimuth: 0.205
        };
        var pmremGenerator = new THREE.PMREMGenerator( renderer );
        function updateSun() {
            var theta = Math.PI * ( parameters.inclination - 0.5 );
            var phi = 2 * Math.PI * ( parameters.azimuth - 0.5 );
            sun.x = Math.cos( phi );
            sun.y = Math.sin( phi ) * Math.sin( theta );
            sun.z = Math.sin( phi ) * Math.cos( theta );
            sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
            water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();
            scene.environment = pmremGenerator.fromScene( sky ).texture;
        }
        updateSun();
      }

      function loadFile(file,manager) {
        let loader = new THREE.FileLoader(manager);
        let blob = null;
        loader.responseType = "blob";
        loader.load(file,
          function(data) {
            getAsText(data,file);
          },
          function(xhr) {
            console.log((file+' '+xhr.loaded/xhr.total*100)+'% loaded');
          },
          function(err) {
            console.error('An error happened when loading '+file);
          }
        );
      }

      //load ground OBJ file
      function objLoader(obj_url,obj_material) {
        var loader = new OBJLoader();
        loader.load(
            obj_url,
            function ( object ) {
                object.traverse(function(child){
                    console.log("child type: "+child.type);
                    if(child.type == "Mesh") {
                        child.material = obj_material;
                    }
                });
                object.position.x=-140;
                object.position.z=20;
                object.scale.set(33,1,33);
                
                scene.add( object );
            },
            function ( xhr ) {
                console.log( obj_url + ' ' + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            function ( error ) {
                console.log( 'An error happened when loading ' + obj_url );
            }
        );
      }

      function getAsText(file,url) {
        let reader = new FileReader();
        reader.readAsText(file);
        reader.onProgress = updateProgress;
        reader.onload = loaded;
        reader.onerror = errorHandler;
        reader.url = url;
        let text = reader.result;
      }

      function updateProgress(evt) {
        if(evt.lengthComputable) {
          let loaded = (evt.loaded/evt.total);
        }
      }

      function loaded(evt) {
        let fileString = evt.target.result;
        let isFolder = fileString.startsWith("<!DOCTYPE HTML PUBLIC");
        let lines = null;
        if(isFolder) {
          lines = fileString.split('\n');
          let doc = new DOMParser().parseFromString(fileString, "text/html");
          let files = doc.getElementsByTagName("LI");
          city_to_load = Math.trunc((files.length-1)/2);
          console.log("loaded: city_to_load = "+city_to_load);
          for(let i=0;i<files.length;i++){
            let file_url = source_dir+files[i].firstChild.innerHTML;
            console.log("loaded: loading file: "+file_url);
            loadFile(file_url);
          }
        } else {
          let filename = evt.target.url;
          let layer_name;
          lines = fileString.split('\n');
          let element_count = (lines[0].split(' ')).length;
          if(element_count == 4 || element_count == 5) {
            loadSpiral(lines,filename);
          } else if(element_count == 6) {
            // console.log("color file");
            layer_name = fileToLayer(filename);
            loadColor(lines,layer_name);
          } else if(element_count == 3) {
            // console.log("floor file");
            layer_name = fileToLayer(filename);
            loadFloor(lines,layer_name);
          }
        }
      }

      function fileToLayer(filename) {
        let start = filename.lastIndexOf('/');
        let end = filename.lastIndexOf('_');
        return filename.substring(start+1,end);
      }

      function getLayerAllObj(layer_name) {
        let layer_all = {
          coords:[],
          colors:{},
          shapes:[],
          b_value:0
        };
        return layer_all;
      }

      function getLayerTrackingObj(layer_name) {
        let layer_tracking = {
          ready_to_move: false,
          ready_to_color: false
        };
        return layer_tracking;
      }

      function printGlobalDict(func) {
        console.log(func + ": city_all");
        console.log(city_all);
        console.log(func + ": city_tracking");
        console.log(city_tracking);
      }

      // add a new floor shape to a given building
      function addNewFloor(layer_name, h, inner_r, outer_r) {
        let floor = {
          height: h,
          inner_radius: inner_r,
          outer_radius: outer_r
        }
        city_all[layer_name].shapes.push(floor);
      }

      // take layer name and lines from floor file, update the shape of building
      function loadFloor(lines,layer_name) {
        // console.log("loadFloor: "+layer_name);
        if (!(layer_name) in city_all) {
          city_all[layer_name] = getLayerAllObj(layer_name);
        } else if (!(layer_name) in city_all) {
          city_all[layer_name] = getLayerTrackingObj(layer_name);
        }
        let i;
        let tmp_outer_radius = 0;
        
        for(i=0; i<lines.length; i++) {
            let elements = lines[i].split(' ');
            // console.log("loadFloor: floor "+i);
            // console.log(elements);
            if (elements.length == 3) {
                if (elements[1] == 0) {
                  // console.log("loadFloor: add new floor "+city_all[layer_name].shapes.length);
                  addNewFloor(layer_name,0.0,parseFloat(elements[2]),0.0);
                } 
                else if (i%2 == 0 && i < lines.length-2) {
                  tmp_outer_radius = elements[2];
                } 
                else if (i%2 == 1) {
                  // console.log("loadFloor: add new floor "+city_all[layer_name].shapes.length);
                  if(i == lines.length-2) {
                      tmp_outer_radius = 0;
                  }
                  // console.log("loadFloor: add new floor "+elements[0]+' '+elements[1]+' '+elements[2]+' '+tmp_outer_radius);
                  addNewFloor(layer_name,parseFloat(elements[1]),parseFloat(elements[2]),parseFloat(tmp_outer_radius));
                }
            }
        }
        city_all[layer_name].b_value = lines[lines.length-1];
        // shape of building is ready, check if coordinated is ready
        if(city_all[layer_name].coords.length > 0) {
          city_tracking[layer_name].ready_to_move = true;
        }
        // printGlobalDict("loadFloor");
      }

      // take color file of a layer and save information to global dictionary
      function loadColor(color_list,layer_name) {
        // console.log("loadColor: " +layer_name);
        if (!(layer_name in city_all)) {
          city_all[layer_name] = getLayerAllObj(layer_name);
        }
        if (!(layer_name in city_tracking)) {
          city_tracking[layer_name] = getLayerTrackingObj(layer_name);
        }
        // inner structure of colors in layer_all dictionary
        let color_dict = {
          disc:[],
          inner:[],
          outer:[]
        };
        // read lines from a color file into "colors" dictionary
        let i;
        for(i=0; i<color_list.length; i++) {
          let elements = color_list[i].split(' ');
          let rgb = {
              r: parseFloat(elements[3]),
              g: parseFloat(elements[4]),
              b: parseFloat(elements[5])
          };
          if (color_list[i].search("disc")>0) {
            color_dict.disc.push(rgb);
          } else if (color_list[i].search("inner")>0) {
            color_dict.inner.push(rgb);
          } else if (color_list[i].search("outer")>0) {
            color_dict.outer.push(rgb);
          }
        }
        city_all[layer_name].colors = color_dict;
        city_tracking[layer_name].ready_to_color = true;
        // printGlobalDict("loadColor");
      }

      function loadSpiral(lines,filename) {
        // console.log("loading spiral");
        // console.log(filename);
        for(let i=0; i<lines.length-1; i++) {
          let elements = lines[i].split(' ');
          let layer_name = elements[0];
          //update global dictionaries if new layer appears
          if (!(layer_name in city_tracking)) {
            city_tracking[layer_name] = getLayerTrackingObj(layer_name);
          }
          if (!(layer_name in city_all)) {
            city_all[layer_name] = getLayerAllObj(layer_name);
          }
          city_all[layer_name].coords = [elements[1]/x_scale, elements[2]/x_scale, elements[0]]; /* X, Z, rotation */
          //coordinates is ready, check if shape of building is ready
          if(city_all[layer_name].shapes.length > 0) {
            city_tracking[layer_name].ready_to_move = true;
          }
        }
        // printGlobalDict("loadSpiral");
      }

      function errorHandler(evt) {
        if(evt.target.error.name == "NotReadableError") {
          console.log("The file could not be read");
        }
      }

      function colorToHex(c) {
        let hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
      }

      // RGB in [0,255]
      function rgbToHex(r,g,b) {
        return parseInt("0x"+colorToHex(r)+colorToHex(g)+colorToHex(b));
      }

      //given a normalized vector, compute the Euler angles of rotation for bars in truss structure
      function truss_rotate(b) {
        let i,j;
        let a = [0,1,0];
        b[0] = -b[0];
        b[2] = -b[2];
        let v = [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];
        let c = a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
        let I = [[1,0,0],[0,1,0],[0,0,1]];
        let v_matrix = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]];
        let v_matrix_2 = [[-v[2]*v[2]-v[1]*v[1],v[0]*v[1],v[0]*v[2]],[v[0]*v[1],-v[0]*v[0]-v[2]*v[2],v[1]*v[2]],[v[0]*v[2],v[1]*v[2],-v[0]*v[0]-v[1]*v[1]]];
        let R = [];
        if(c == -1) {
          for(j=0; j<3; j++) {
            let line = [];
            for(i=0; i<3; i++) {
              line.push(I[i][j] + v_matrix[i][j] + v_matrix_2[i][j]);
            }
            R.push(line);
          }
        } else {
          for(j=0; j<3; j++) {
            let line = [];
            for(i=0; i<3; i++) {
              line.push(I[i][j] + v_matrix[i][j] + v_matrix_2[i][j]/(1+c));
            }
            R.push(line);
          }
        }
        let sy = Math.sqrt(R[0][0]*R[0][0]+R[1][0]*R[1][0]);
        // https://www.learnopencv.com/rotation-matrix-to-euler-angles/
        let singular = sy<1e-8;
        let x,y,z;
        if(!singular) {
          x = Math.atan2(R[2][1],R[2][2]);
          y = Math.atan2(-R[2][0],sy);
          z = Math.atan2(R[1][0],R[0][0]);
        } else {
          x = Math.atan2(-R[1][2],R[1][1]);
          y = Math.atan2(-R[2][0],sy);
          z = 0;
        }
         let rotate_rad = [x,y,z];
        return rotate_rad;
      }

      function mag(v) {
        return Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
      }

      function normalize(v) {
        let length = mag(v);
        let i;
        let normalized = [];
        for(i=0; i<3; i++) {
          normalized.push(v[i]/length);
        }
        return normalized;
      }

      function obtain_truss(center,top_radius,btm_radius,height,r,g,b) {
        let thickness = 0.1;
        let number = 6;
        let truss_geo = new THREE.BufferGeometry();
        let i;
        for (i = 0; i<number; i++) {
          let theta = i*(360/number);
          let theta_sin = Math.sin(theta*Math.PI/180);
          let theta_cos = Math.cos(theta*Math.PI/180);
          let top = [theta_cos*top_radius,height/2,theta_sin*top_radius];
          let btm = [theta_cos*btm_radius,-height/2,theta_sin*btm_radius];
          let top_btm = [top[0]-btm[0], top[1]-btm[1], top[2]-btm[2]];
          let length = mag(top_btm);
          let normalized_top_btm = normalize(top_btm);
          let mid_radius = (top_radius+btm_radius)/2;
          let bar_center = [center[0]+theta_cos*mid_radius,center[1],center[2]+theta_sin*mid_radius];
          let bar = new THREE.CylinderBufferGeometry(thickness,thickness,length,8,8);
          // rotate the side bars
          let rotated = truss_rotate(normalized_top_btm);
          bar.rotateX(rotated[0]);
          bar.rotateY(rotated[1]);
          bar.rotateZ(rotated[2]);
          bar.translate(bar_center[0],bar_center[1],bar_center[2]);
          let bar_mesh = new THREE.Mesh(bar);
          bar_mesh.updateMatrix();
          // merge all bars together
          BufferGeometryUtils.mergeBufferGeometries([truss_geo,bar_mesh.geometry],bar_mesh.matrix);
        }
        // create torus geometry
        let torus_geo = new THREE.TorusGeometry(top_radius,thickness,16,100);
        torus_geo.rotateX(90*Math.PI/180);
        let material = new THREE.MeshBasicMaterial({color:rgbToHex(r,g,b)});
        let torus_mesh = new THREE.Mesh(torus_geo, material);
        let torus_flat = new THREE.Object3D();
        torus_flat.add(torus_mesh);
        torus_flat.translateX(center[0]);
        torus_flat.translateY(center[1]+height/2);
        torus_flat.translateZ(center[2]);
        // scene.add(torus_flat);
        // merge torus with bars
        // truss_geo.merge(torus_mesh.geometry,torus_mesh.matrix);
        // truss_geo.merge(torus_flat.geometry,torus_flat.matrix);
        let truss_mesh = new THREE.Mesh(truss_geo,material);
        return truss_mesh;
      }

      // check city_tracking, create buildings that are ready to color & move
      // delete colored and moved building from city_tracking
      function createCityMeshes() {
        for (let layer in city_tracking) {
            if(city_tracking[layer].ready_to_move && city_tracking[layer].ready_to_color) {
                let layer_shape = city_all[layer].shapes;
                let height = layer_shape.length;
                // translate in X,Z direction
                let X = city_all[layer].coords[0];
                let Z = city_all[layer].coords[1];
                // // create grass polygon
                // let grass_edge = Math.log2(city_all[layer].b_value);
                // let grass_radius = 24.56992917882274 / 2;
                // let grass_mesh = new THREE.Mesh( 
                //   new THREE.CylinderBufferGeometry(grass_radius, grass_radius, 0.5, grass_edge), 
                //   new THREE.MeshBasicMaterial({color: 0x567d46})
                // );
                // grass_mesh.translateX = X;
                // grass_mesh.translateY = 0.2;
                // grass_mesh.translateZ = Z;
                // scene.add(grass_mesh);
                // loop from bottom floor to top floor
                for (let h=1; h<height; h++) {
                    // translate in Y direction
                    let Y = y_scale*(0.5*layer_shape[h].height + 0.5*layer_shape[h-1].height);
                    // create inner frustum geometry
                    let top_in_r = layer_shape[h].inner_radius;
                    let btm_in_r = layer_shape[h-1].inner_radius;
                    let tall = y_scale*(layer_shape[h].height - layer_shape[h-1].height);
                    let floor = new THREE.CylinderBufferGeometry(top_in_r,btm_in_r,tall,16,16);
                    floor.translate(X,Y,Z);
                    // apply colors
                    let r, g, b;
                    try {
                        r = parseInt(city_all[layer].colors.inner[h-1].r*255);
                        g = parseInt(city_all[layer].colors.inner[h-1].g*255);
                        b = parseInt(city_all[layer].colors.inner[h-1].b*255);    
                    } catch(err) {
                        console.log(err.message+" "+layer);
                    }
                    let material = new THREE.MeshBasicMaterial({color:rgbToHex(r,g,b)});
                    let frustum_mesh = new THREE.Mesh(floor,material);
                    frustum_mesh.floor_name = h;
                    frustum_mesh.layer_name = layer.substring(8);
                    // draw inner frustums
                    scene.add(frustum_mesh);
                    objects.push(frustum_mesh);

                    // outer frustums
                    if(h<height-1) {
                        //create outer frustum as truss structure
                        let top_out_r = layer_shape[h].outer_radius;
                        let btm_out_r = layer_shape[h-1].inner_radius;
                        r = parseInt(city_all[layer].colors.outer[h-1].r*255);
                        g = parseInt(city_all[layer].colors.outer[h-1].g*255);
                        b = parseInt(city_all[layer].colors.outer[h-1].b*255);
                        let truss_mesh = obtain_truss([X,Y,Z],top_out_r,btm_out_r,tall,r,g,b);
                        // console.log("createCityMeshes: create a set of truss");
                        // draw outer frustums
                        // scene.add(truss_mesh);
                    }
                }
                console.log("createCityMeshes: loaded "+layer+", city to load = "+city_to_load);
                delete city_tracking[layer];
                --city_to_load;
                
            }
        }
      }

      function createControls( camera ) {
        controls = new TrackballControls( camera, renderer.domElement );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.keys = [ 65, 83, 68 ];
      }

      function onWindowResize() {

        let aspect = window.innerWidth / window.innerHeight;

        perspectiveCamera.aspect = aspect;
        perspectiveCamera.updateProjectionMatrix();

        orthographicCamera.left = - frustumSize * aspect / 2;
        orthographicCamera.right = frustumSize * aspect / 2;
        orthographicCamera.top = frustumSize / 2;
        orthographicCamera.bottom = - frustumSize / 2;
        orthographicCamera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

      }
      
      function animate() {
        requestAnimationFrame( animate );
        controls.update();
        // stats.update();
        if(city_to_load>0) {
          console.log("animate: run createCityMeshes()");
          createCityMeshes();

        }
        render();
      }

      function render() {
        let camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
        renderer.render(scene, camera);
        // let time = performance.now() * 0.001;
        // water.material.uniforms[ 'time' ].value += 1.0 / 60.0;
      }

      function onMouseMove( event ) {
        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
        let camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
        raycaster.setFromCamera( mouse, camera );

        let intersects = raycaster.intersectObjects( objects );
        // Toggle rotation bool for meshes that we clicked
        if (intersects.length > 0) {
          // if the closest object intersected is not the currently stored intersection object
          if (intersects[0].object != INTERSECTED ) {
            INTERSECTED = intersects[0].object;
            if(intersects[0].object.floor_name) {
              building_params.floor = intersects[0].object.floor_name;
            } else {
              building_params.floor = '';
            }
            if(intersects[0].object.layer_name) {
              building_params.layer = intersects[0].object.layer_name;
            } else {
              building_params.layer = '';
            }
          }
        } else // there are no intersections
        {
          INTERSECTED = null;
          building_params.floor='';
          building_params.layer='';
        }
      }
    </script>
  </body>
</html>