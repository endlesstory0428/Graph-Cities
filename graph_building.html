<html>
	<head>
		<title>Graph City Building</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!-- <link type="text/css" rel="stylesheet" href="./three.js/editor/css/main.css"> -->
		<script src="lib/jquery-3.5.1.min.js"> </script>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script type="module">
			import * as THREE from './node_modules/three/build/three.module.js';
			import { TrackballControls } from './node_modules/three/examples/jsm/controls/TrackballControls.js';
			import { GUI } from './node_modules/three/examples/jsm/libs/dat.gui.module.js';
			THREE.Cache.enabled = true;

			var perspectiveCamera, orthographicCamera, controls, scene, renderer;

			var params = {
				orthographicCamera: false
			};
			var building = {
			    floor: ''
			};
			var frustumSize = 400;
			var aspect = window.innerWidth/window.innerHeight;
			var scene = new THREE.Scene();
			scene.background = new THREE.Color('skyblue');
			// var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();
			var gui = new GUI();
			var objects = [];
			var INTERSECTED;
			var fileText = null;
			

			init();
			animate();

			function init() {
				perspectiveCamera = new THREE.PerspectiveCamera( 60, aspect, 1, 1000 );
				perspectiveCamera.position.z = 20;

				orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );
				orthographicCamera.position.z = 20;

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				
				var manager = new THREE.LoadingManager();
				manager.onStart = function(url,itemsLoaded,itemsTotal) {
					console.log('Started loading file: '+url+'.\nLoaded '+itemsLoaded+' of '+itemsTotal+' files.');
				};
				// manager.onLoad = function() {
				// 	console.log('Loading complete!');
				// }
				// manager.onProgress = function(url,itemsLoaded,itemsTotal) {
				// 	console.log('Started loading file: '+url+'.\nLoaded '+itemsLoaded+' of '+itemsTotal+' files.');
				// };
				// manager.onError = function(url) {
				// 	console.log('There was an error loading '+url);
				// }


				loadFile('data/example.txt',manager);
				loadFile('data/',manager);

				var heights = [0,0.0877794886782907,0.13128609409319691,0.1747926995081031,0.22819410025109796,0.2815955009940928,0.35019479832400946,0.4187940956539261,0.6061428892410488];
				for(var i=0;i<heights.length;i++) {
					heights[i]*=10;
				}
				var radius = [6.066089190457772,3.0,3.4594316186372973,2.321928094887362,2.584962500721156,0.98,2.0,1.0,1.584962500721156];
				var floor1 = new THREE.CylinderBufferGeometry(radius[1], radius[0], heights[1]-heights[0], 16, 16);
				floor1.translate(0,heights[1]/2,0);
				var floor2 = new THREE.CylinderBufferGeometry(radius[2], radius[1], heights[2]-heights[1], 16, 16);
				floor2.translate(0,heights[1]+(heights[2]-heights[1])/2,0);
				var floor3 = new THREE.CylinderBufferGeometry(radius[3], radius[2], heights[3]-heights[2], 16, 16);
				floor3.translate(0,heights[2]+(heights[3]-heights[2])/2,0);
				var floor4 = new THREE.CylinderBufferGeometry(radius[4], radius[3], heights[4]-heights[3], 16, 16);
				floor4.translate(0,heights[3]+(heights[4]-heights[3])/2,0);
				var floor5 = new THREE.CylinderBufferGeometry(radius[5], radius[4], heights[5]-heights[4], 16, 16);
				floor5.translate(0,heights[4]+(heights[5]-heights[4])/2,0);
				var floor6 = new THREE.CylinderBufferGeometry(radius[6], radius[5], heights[6]-heights[5], 16, 16);
				floor6.translate(0,heights[5]+(heights[6]-heights[5])/2,0);
				var floor7 = new THREE.CylinderBufferGeometry(radius[7], radius[6], heights[7]-heights[6], 16, 16);
				floor7.translate(0,heights[6]+(heights[7]-heights[6])/2,0);
				// Colors
				var material1 = new THREE.MeshBasicMaterial({color:0xEC3613});
				var material2 = new THREE.MeshBasicMaterial({color:0xECA113});
				var material3 = new THREE.MeshBasicMaterial({color:0xC1EC13});
				var material4 = new THREE.MeshBasicMaterial({color:0x13EC13});
				var material5 = new THREE.MeshBasicMaterial({color:0x1313EC});

				// Mesh
				var frustum_mesh_1 = new THREE.Mesh(floor1, material1);
				frustum_mesh_1.name="floor 1"
				var frustum_mesh_2 = new THREE.Mesh(floor2, material2);
				frustum_mesh_2.name="floor 2"
				var frustum_mesh_3 = new THREE.Mesh(floor3, material2);
				frustum_mesh_3.name="floor 3"
				var frustum_mesh_4 = new THREE.Mesh(floor4, material3);
				frustum_mesh_4.name="floor 4"
				var frustum_mesh_5 = new THREE.Mesh(floor5, material3);
				frustum_mesh_5.name="floor 5"
				var frustum_mesh_6 = new THREE.Mesh(floor6, material4);
				frustum_mesh_6.name="floor 6"
				var frustum_mesh_7 = new THREE.Mesh(floor7, material5);
				frustum_mesh_7.name="floor 7"
				// var frustum_mesh_3 = new THREE.Mesh(floor2, material2);
				// var building_mesh_1 = new THREE.Mesh(THREE.Geometry());
				// building_mesh_1.merge(floor1);
				// building_mesh_1.merge(floor2);
				// var building_mesh_1 = new THREE.Mesh(building1,material1);
				// scene.add(building_mesh_1);
				scene.add(frustum_mesh_1);
				scene.add(frustum_mesh_2);
				scene.add(frustum_mesh_3);
				scene.add(frustum_mesh_4);
				scene.add(frustum_mesh_5);
				scene.add(frustum_mesh_6);
				scene.add(frustum_mesh_7);
				objects.push(frustum_mesh_1);
				objects.push(frustum_mesh_2);
				objects.push(frustum_mesh_3);
				objects.push(frustum_mesh_4);
				objects.push(frustum_mesh_5);
				objects.push(frustum_mesh_6);
				objects.push(frustum_mesh_7);

				// camera.position.z = 15;
				// camera.position.y = 2;

				
				gui.add( params, 'orthographicCamera' ).name( 'use orthographic' ).onChange( function ( value ) {

					controls.dispose();

					createControls( value ? orthographicCamera : perspectiveCamera );

				} );

				gui.add(building, 'floor').name('floor number').listen();

				document.body.appendChild( renderer.domElement );
				document.addEventListener( 'mousemove', onMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );
				createControls( perspectiveCamera );	
			}

			function loadFile(file,manager) {
				var loader = new THREE.FileLoader(manager);
				var blob = null;
				loader.responseType = "blob";
				loader.load(file,
					function(data) {
						getAsText(data);
					},
					function(xhr) {
						console.log((file+' '+xhr.loaded/xhr.total*100)+'% loaded');
					},
					function(err) {
						console.error('An error happened when loading '+file);
					}
				);
			}

			function getAsText(file) {
				var reader = new FileReader();
				reader.readAsText(file);
				reader.onProgress = updateProgress;
				reader.onload = loaded;
				reader.onerror = errorHandler;
				var text = reader.result;
			}

			function updateProgress(evt) {
				if(evt.lengthComputable) {
					var loaded = (evt.loaded/evt.total);
				}
			}

			function loaded(evt) {
				var fileString = evt.target.result;
				console.log(fileString);
				var isFolder = fileString.startsWith("<!DOCTYPE HTML PUBLIC");
				var lines = null;
				if(isFolder) {
					lines = fileString.split("\n");
					var doc = new DOMParser().parseFromString(fileString, "text/html");
					// console.log(doc);
					var files = doc.getElementsByTagName("LI");
					console.log(files);
					console.log(files[0].firstChild.innerHTML);
				}
			}

			function errorHandler(evt) {
				if(evt.target.error.name == "NotReadableError") {
					console.log("The file could not be read");
				}
			}

			function createControls( camera ) {
				controls = new TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.keys = [ 65, 83, 68 ];
			}

			function onWindowResize() {

				var aspect = window.innerWidth / window.innerHeight;

				perspectiveCamera.aspect = aspect;
				perspectiveCamera.updateProjectionMatrix();

				orthographicCamera.left = - frustumSize * aspect / 2;
				orthographicCamera.right = frustumSize * aspect / 2;
				orthographicCamera.top = frustumSize / 2;
				orthographicCamera.bottom = - frustumSize / 2;
				orthographicCamera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();

			}
			
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				// stats.update();
				render();
			}

			function render() {
				var camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
				renderer.render(scene, camera);
			}

			function onMouseMove( event ) {
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				var camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );
				// Toggle rotation bool for meshes that we clicked
				if ( intersects.length > 0 ) {
					// if the closest object intersected is not the currently stored intersection object
					if ( intersects[ 0 ].object != INTERSECTED ) 
					{
						INTERSECTED = intersects[ 0 ].object;
						if ( intersects[ 0 ].object.name )
						{
							console.log(intersects[ 0 ].object.name);
							building.floor=intersects[ 0 ].object.name;
						}
						else
						{
							building.floor='';
						}
					}
				} else // there are no intersections
				{
					INTERSECTED = null;
					building.floor='';
				}
			}
		</script>
	</body>
</html>