<html>
  <head>
    <title>Graph City Building</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- <link type="text/css" rel="stylesheet" href="./three.js/editor/css/main.css"> -->
    <script src="lib/jquery-3.5.1.min.js"> </script>
    <style>
      body { margin: 0; }
      canvas { display: block; }
    </style>
    <script> 
        function locationreload() { 
            location.reload(); 
        } 
    </script> 
  </head>
  <body>
    <script type="module">
      import * as THREE from './node_modules/three/build/three.module.js';
      import { TrackballControls } from './node_modules/three/examples/jsm/controls/TrackballControls.js';
      import { GUI } from './node_modules/three/examples/jsm/libs/dat.gui.module.js';
      import { BufferGeometryUtils } from './three.js/examples/jsm/utils/BufferGeometryUtils.js';
      // THREE.Cache.enabled = true;

      var perspectiveCamera, orthographicCamera, controls, scene, renderer;

      var spiral = [];
      var frustumSize = 400;
      var aspect = window.innerWidth/window.innerHeight;
      var scene = new THREE.Scene();
      scene.background = new THREE.Color('skyblue');
      // var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var objects = [];
      var INTERSECTED;
      var city_tracking = {};
      var city_all = {};
      var city_mesh = [];
      var city_to_load = 0;
      var groundMesh;
      var source_dir = "data/";
      // var source_dir;
      var y_scale = 10; // scale up the height of building
      var x_scale = 800000.0; // scale down the coordinates span
      var default_persp = [0,200,400]
        // GUI parameters
        var params = {
            orthographicCamera: false,
            resetCamera: function() {
                // TrackballControls.reset();
            },
            ground: "#8B4513",
            colorMap: "jet",
            hideBuilding: false
        };
        var building_params = {
            floor: '',
            layer: ''
        };

      init();
      animate();

      function init() {
        perspectiveCamera = new THREE.PerspectiveCamera( 60, aspect, 1, 2000 );
        perspectiveCamera.position.z = 400;
        perspectiveCamera.position.y = 200;

        orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );
        orthographicCamera.position.z = 20;

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        
        var manager = new THREE.LoadingManager();
        manager.onStart = function(url,itemsLoaded,itemsTotal) {
          console.log('Started loading file: '+url+'.\nLoaded '+itemsLoaded+' of '+itemsTotal+' files.');
        };

        loadFile(source_dir,manager);

        // GUI folders
        var gui = new GUI();
        var f1 = gui.addFolder('Building Info');
        f1.add(building_params, 'floor').name('floor number').listen();
        f1.add(building_params, 'layer').name('layer info').listen();
        f1.add(params, 'colorMap', ['jet','others']).name('color map').onChange(function () {
            // updateColorMap();
            render();
        });
        f1.open();
        var f2 = gui.addFolder('Camera Control');
        f2.add(params, 'resetCamera').name('reset camera');
        f2.add(params, 'orthographicCamera').name('use orthographic').onChange(
            function( value ) {
                // controls.dispose();
            createControls( value ? orthographicCamera : perspectiveCamera );
        });
        f2.open();
        var f3 = gui.addFolder('Environment Control');
        f3.addColor(params, 'ground').name('ground color').onChange( function( colorValue ) {
            colorValue = parseInt(colorValue.replace('#','0x'),16);
            var colorObject = new THREE.Color( colorValue );
            groundMesh.material.color = colorObject;
            animate();
        });
        f3.open();

        // ground
        var groundGeo = new THREE.BoxBufferGeometry(800,0.1,800);
        var groundMat = new THREE.MeshBasicMaterial( {color:params.ground} );
        groundMesh = new THREE.Mesh( groundGeo, groundMat );
        groundMesh.translateY(-0.1);
        scene.add( groundMesh );

        document.body.appendChild( renderer.domElement );
        document.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'resize', onWindowResize, false );
        // window.addEventListener( 'reset_camera', onResetCamera, false);
        createControls( perspectiveCamera );

        var size = 800;
        var divisions = 80;
        var gridHelper = new THREE.GridHelper( size, divisions );
        scene.add( gridHelper );
      }

      function loadFile(file,manager) {
        var loader = new THREE.FileLoader(manager);
        var blob = null;
        loader.responseType = "blob";
        loader.load(file,
          function(data) {
            getAsText(data,file);
          },
          function(xhr) {
            console.log((file+' '+xhr.loaded/xhr.total*100)+'% loaded');
          },
          function(err) {
            console.error('An error happened when loading '+file);
          }
        );
      }

      function getAsText(file,url) {
        var reader = new FileReader();
        reader.readAsText(file);
        reader.onProgress = updateProgress;
        reader.onload = loaded;
        reader.onerror = errorHandler;
        reader.url = url;
        var text = reader.result;
      }

      function updateProgress(evt) {
        if(evt.lengthComputable) {
          var loaded = (evt.loaded/evt.total);
        }
      }

      function loaded(evt) {
        var fileString = evt.target.result;
        var isFolder = fileString.startsWith("<!DOCTYPE HTML PUBLIC");
        var lines = null;
        if(isFolder) {
          lines = fileString.split('\n');
          var doc = new DOMParser().parseFromString(fileString, "text/html");
          var files = doc.getElementsByTagName("LI");
          city_to_load = Math.trunc((files.length-1)/2);
          console.log("loaded: city_to_load = "+city_to_load);
          for(var i=0;i<files.length;i++){
            var file_url = source_dir+files[i].firstChild.innerHTML;
            console.log("loaded: loading file: "+file_url);
            loadFile(file_url);
          }
        } else {
          var filename = evt.target.url;
          var layer_name;
          lines = fileString.split('\n');
          var element_count = (lines[0].split(' ')).length;
          if(element_count == 4) {
            loadSpiral(lines,filename);
          } else if(element_count == 6) {
            // console.log("color file");
            layer_name = fileToLayer(filename);
            loadColor(lines,layer_name);
          } else if(element_count == 3) {
            // console.log("floor file");
            layer_name = fileToLayer(filename);
            loadFloor(lines,layer_name);
          }
        }
      }

      function fileToLayer(filename) {
        var start = filename.lastIndexOf('/');
        var end = filename.lastIndexOf('_');
        return filename.substring(start+1,end);
      }

      function getLayerAllObj(layer_name) {
        var layer_all = {
          coords:[],
          colors:{},
          shapes:[]
        };
        return layer_all;
      }

      function getLayerTrackingObj(layer_name) {
        var layer_tracking = {
          ready_to_move: false,
          ready_to_color: false
        };
        return layer_tracking;
      }

      function printGlobalDict(func) {
        console.log(func + ": city_all");
        console.log(city_all);
        console.log(func + ": city_tracking");
        console.log(city_tracking);
      }

      // add a new floor shape to a given building
      function addNewFloor(layer_name, h, inner_r, outer_r) {
        var floor = {
          height: h,
          inner_radius: inner_r,
          outer_radius: outer_r
        }
        city_all[layer_name].shapes.push(floor);
      }

      // take layer name and lines from floor file, update the shape of building
      function loadFloor(lines,layer_name) {
        // console.log("loadFloor: "+layer_name);
        if (!(layer_name) in city_all) {
          city_all[layer_name] = getLayerAllObj(layer_name);
        } else if (!(layer_name) in city_all) {
          city_all[layer_name] = getLayerTrackingObj(layer_name);
        }
        var i;
        var tmp_outer_radius = 0;
        
        for(i=0; i<lines.length; i++) {
            var elements = lines[i].split(' ');
            // console.log("loadFloor: floor "+i);
            // console.log(elements);
            if (elements.length == 3) {
                if (elements[1] == 0) {
                    // console.log("loadFloor: add new floor "+city_all[layer_name].shapes.length);
                    addNewFloor(layer_name,0.0,parseFloat(elements[2]),0.0);
                    } else if (i%2 == 0 && i < lines.length-2) {
                    tmp_outer_radius = elements[2];
                    } else if (i%2 == 1) {
                    // console.log("loadFloor: add new floor "+city_all[layer_name].shapes.length);
                    if(i == lines.length-2) {
                      tmp_outer_radius = 0;
                    }
                    // console.log("loadFloor: add new floor "+elements[0]+' '+elements[1]+' '+elements[2]+' '+tmp_outer_radius);
                    addNewFloor(layer_name,parseFloat(elements[1]),parseFloat(elements[2]),parseFloat(tmp_outer_radius));
                }
            }
        }
        // shape of building is ready, check if coordinated is ready
        if(city_all[layer_name].coords.length > 0) {
          city_tracking[layer_name].ready_to_move = true;
        }
        // printGlobalDict("loadFloor");
      }

      // take color file of a layer and save information to global dictionary
      function loadColor(color_list,layer_name) {
        // console.log("loadColor: " +layer_name);
        if (!(layer_name in city_all)) {
          city_all[layer_name] = getLayerAllObj(layer_name);
        }
        if (!(layer_name in city_tracking)) {
          city_tracking[layer_name] = getLayerTrackingObj(layer_name);
        }
        // inner structure of colors in layer_all dictionary
        var color_dict = {
          disc:[],
          inner:[],
          outer:[]
        };
        // read lines from a color file into "colors" dictionary
        var i;
        for(i=0; i<color_list.length; i++) {
          var elements = color_list[i].split(' ');
          var rgb = {
              r: parseFloat(elements[3]),
              g: parseFloat(elements[4]),
              b: parseFloat(elements[5])
          };
          if (color_list[i].search("disc")>0) {
            color_dict.disc.push(rgb);
          } else if (color_list[i].search("inner")>0) {
            color_dict.inner.push(rgb);
          } else if (color_list[i].search("outer")>0) {
            color_dict.outer.push(rgb);
          }
        }
        city_all[layer_name].colors = color_dict;
        city_tracking[layer_name].ready_to_color = true;
        // printGlobalDict("loadColor");
      }

      function loadSpiral(lines,filename) {
        // console.log("loading spiral");
        // console.log(filename);
        for(var i=0; i<lines.length-1; i++) {
          var elements = lines[i].split(' ');
          var layer_name = elements[0];
          //update global dictionaries if new layer appears
          if (!(layer_name in city_tracking)) {
            city_tracking[layer_name] = getLayerTrackingObj(layer_name);
          }
          if (!(layer_name in city_all)) {
            city_all[layer_name] = getLayerAllObj(layer_name);
          }
          city_all[layer_name].coords = [elements[1]/x_scale, elements[2]/x_scale];
          //coordinates is ready, check if shape of building is ready
          if(city_all[layer_name].shapes.length > 0) {
            city_tracking[layer_name].ready_to_move = true;
          }
        }
        // printGlobalDict("loadSpiral");
      }

      function errorHandler(evt) {
        if(evt.target.error.name == "NotReadableError") {
          console.log("The file could not be read");
        }
      }

      function colorToHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
      }

      // RGB in [0,255]
      function rgbToHex(r,g,b) {
        return parseInt("0x"+colorToHex(r)+colorToHex(g)+colorToHex(b));
      }

      //given a normalized vector, compute the Euler angles of rotation for bars in truss structure
      function truss_rotate(b) {
        var i,j;
        var a = [0,1,0];
        b[0] = -b[0];
        b[2] = -b[2];
        var v = [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];
        var c = a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
        var I = [[1,0,0],[0,1,0],[0,0,1]];
        var v_matrix = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]];
        var v_matrix_2 = [[-v[2]*v[2]-v[1]*v[1],v[0]*v[1],v[0]*v[2]],[v[0]*v[1],-v[0]*v[0]-v[2]*v[2],v[1]*v[2]],[v[0]*v[2],v[1]*v[2],-v[0]*v[0]-v[1]*v[1]]];
        var R = [];
        if(c == -1) {
          for(j=0; j<3; j++) {
            var line = [];
            for(i=0; i<3; i++) {
              line.push(I[i][j] + v_matrix[i][j] + v_matrix_2[i][j]);
            }
            R.push(line);
          }
        } else {
          for(j=0; j<3; j++) {
            var line = [];
            for(i=0; i<3; i++) {
              line.push(I[i][j] + v_matrix[i][j] + v_matrix_2[i][j]/(1+c));
            }
            R.push(line);
          }
        }
        var sy = Math.sqrt(R[0][0]*R[0][0]+R[1][0]*R[1][0]);
        // https://www.learnopencv.com/rotation-matrix-to-euler-angles/
        var singular = sy<1e-8;
        var x,y,z;
        if(!singular) {
          x = Math.atan2(R[2][1],R[2][2]);
          y = Math.atan2(-R[2][0],sy);
          z = Math.atan2(R[1][0],R[0][0]);
        } else {
          x = Math.atan2(-R[1][2],R[1][1]);
          y = Math.atan2(-R[2][0],sy);
          z = 0;
        }
         var rotate_rad = [x,y,z];
        return rotate_rad;
      }

      function mag(v) {
        return Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
      }

      function normalize(v) {
        var length = mag(v);
        var i;
        var normalized = [];
        for(i=0; i<3; i++) {
          normalized.push(v[i]/length);
        }
        return normalized;
      }

      function obtain_truss(center,top_radius,btm_radius,height,r,g,b) {
        var thickness = 0.05;
        var number = 6;
        var truss_geo = new THREE.BufferGeometry();
        var i;
        for (i = 0; i<number; i++) {
          var theta = i*(360/number);
          var theta_sin = Math.sin(theta*Math.PI/180);
          var theta_cos = Math.cos(theta*Math.PI/180);
          var top = [theta_cos*top_radius,height/2,theta_sin*top_radius];
          var btm = [theta_cos*btm_radius,-height/2,theta_sin*btm_radius];
          var top_btm = [top[0]-btm[0], top[1]-btm[1], top[2]-btm[2]];
          var length = mag(top_btm);
          var normalized_top_btm = normalize(top_btm);
          var mid_radius = (top_radius+btm_radius)/2;
          var bar_center = [center[0]+theta_cos*mid_radius,center[1],center[2]+theta_sin*mid_radius];
          var bar = new THREE.CylinderBufferGeometry(thickness,thickness,length,8,8);
          // rotate the side bars
          var rotated = truss_rotate(normalized_top_btm);
          bar.rotateX(rotated[0]);
          bar.rotateY(rotated[1]);
          bar.rotateZ(rotated[2]);
          bar.translate(bar_center[0],bar_center[1],bar_center[2]);
          var bar_mesh = new THREE.Mesh(bar);
          bar_mesh.updateMatrix();
          // merge all bars together
          BufferGeometryUtils.mergeBufferGeometries([truss_geo,bar_mesh.geometry],bar_mesh.matrix);
        }
        // create torus geometry
        var torus_geo = new THREE.TorusGeometry(top_radius,thickness,16,100);
        torus_geo.rotateX(90*Math.PI/180);
        var material = new THREE.MeshBasicMaterial({color:rgbToHex(r,g,b)});
        var torus_mesh = new THREE.Mesh(torus_geo, material);
        var torus_flat = new THREE.Object3D();
        torus_flat.add(torus_mesh);
        torus_flat.translateX(center[0]);
        torus_flat.translateY(center[1]+height/2);
        torus_flat.translateZ(center[2]);
        scene.add(torus_flat);
        // merge torus with bars
        // truss_geo.merge(torus_mesh.geometry,torus_mesh.matrix);
        // truss_geo.merge(torus_flat.geometry,torus_flat.matrix);
        var truss_mesh = new THREE.Mesh(truss_geo,material);
        return truss_mesh;
      }

      // check city_tracking, create buildings that are ready to color & move
      // delete colored and moved building from city_tracking
      function createCityMeshes() {
        for (var layer in city_tracking) {
            if(city_tracking[layer].ready_to_move && city_tracking[layer].ready_to_color) {
                var layer_shape = city_all[layer].shapes;
                var height = layer_shape.length;
                // loop from bottom floor to top floor
                var h;
                for (h=1; h<height; h++) {
                    // create inner frustum geometry
                    var top_in_r = layer_shape[h].inner_radius;
                    var btm_in_r = layer_shape[h-1].inner_radius;
                    var tall = y_scale*(layer_shape[h].height - layer_shape[h-1].height);
                    var floor = new THREE.CylinderBufferGeometry(top_in_r,btm_in_r,tall,16,16);
                    // translate in Y direction
                    var Y = y_scale*(0.5*layer_shape[h].height + 0.5*layer_shape[h-1].height);
                    // translate in X,Z direction
                    var X = city_all[layer].coords[0];
                    var Z = city_all[layer].coords[1];
                    // floor.translate(0,Y,0);
                    floor.translate(X,Y,Z);
                    // apply colors
                    try {
                        var r = parseInt(city_all[layer].colors.inner[h-1].r*255);
                        var g = parseInt(city_all[layer].colors.inner[h-1].g*255);
                        var b = parseInt(city_all[layer].colors.inner[h-1].b*255);    
                    } catch(err) {
                        console.log(err.message+" "+layer);
                    }
                    var material = new THREE.MeshBasicMaterial({color:rgbToHex(r,g,b)});
                    var frustum_mesh = new THREE.Mesh(floor,material);
                    frustum_mesh.floor_name = h;
                    frustum_mesh.layer_name = layer.substring(8);
                    // draw inner frustums
                    scene.add(frustum_mesh);
                    objects.push(frustum_mesh);

                    // outer frustums
                    if(h<height-1) {
                        //create outer frustum as truss structure
                        var top_out_r = layer_shape[h].outer_radius;
                        var btm_out_r = layer_shape[h-1].inner_radius;
                        r = parseInt(city_all[layer].colors.outer[h-1].r*255);
                        g = parseInt(city_all[layer].colors.outer[h-1].g*255);
                        b = parseInt(city_all[layer].colors.outer[h-1].b*255);
                        var truss_mesh = obtain_truss([X,Y,Z],top_out_r,btm_out_r,tall,r,g,b);
                        // console.log("createCityMeshes: create a set of truss");
                        // draw outer frustums
                        scene.add(truss_mesh);
                    }
                }
                console.log("createCityMeshes: loaded "+layer+", city to load = "+city_to_load);
                delete city_tracking[layer];
                --city_to_load;
                
            }
        }
      }

      function createControls( camera ) {
        controls = new TrackballControls( camera, renderer.domElement );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.keys = [ 65, 83, 68 ];
      }

      function onWindowResize() {

        var aspect = window.innerWidth / window.innerHeight;

        perspectiveCamera.aspect = aspect;
        perspectiveCamera.updateProjectionMatrix();

        orthographicCamera.left = - frustumSize * aspect / 2;
        orthographicCamera.right = frustumSize * aspect / 2;
        orthographicCamera.top = frustumSize / 2;
        orthographicCamera.bottom = - frustumSize / 2;
        orthographicCamera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

      }
      
      function animate() {
        requestAnimationFrame( animate );
        controls.update();
        // stats.update();
        if(city_to_load>0) {
          console.log("animate: run createCityMeshes()");
          createCityMeshes();

        }
        render();
      }

      function render() {
        var camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
        renderer.render(scene, camera);
      }

      function onMouseMove( event ) {
        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
        var camera = (params.orthographicCamera) ? orthographicCamera : perspectiveCamera;
        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( objects );
        // Toggle rotation bool for meshes that we clicked
        if (intersects.length > 0) {
          // if the closest object intersected is not the currently stored intersection object
          if (intersects[0].object != INTERSECTED ) {
            INTERSECTED = intersects[0].object;
            if(intersects[0].object.floor_name) {
              building_params.floor = intersects[0].object.floor_name;
            } else {
              building_params.floor = '';
            }
            if(intersects[0].object.layer_name) {
              building_params.layer = intersects[0].object.layer_name;
            } else {
              building_params.layer = '';
            }
          }
        } else // there are no intersections
        {
          INTERSECTED = null;
          building_params.floor='';
          building_params.layer='';
        }
      }
    </script>
  </body>
</html>